global _start                   ; делаем метку метку _start видимой извне


section .data                               ; секция данных
    message1: db "Введите число N: "        ; строка для вывода на консоль
    message1_len equ $ - message1           ; Длина message1
    ; equ $ - message1 — автоматически вычисляет длину строки (разница между текущим адресом $ и началом строки message1).
    
    message2: db "Введите позицию P (с конца): "
    message2_len equ $ - message2
    
    error_message: db "Некорректная позиция P", 10
    error_len equ $ - error_message


; Секция .bss (неинициализированные данные)
section .bss
    ; resb — резервирует байты без инициализации (для ввода пользователя)
    N resb 256  ; Буфер на 256 байт для строки N
    P resb 256  ; Буфер на 256 байт для позиции P


section .text                   ;объявление секции кода

_start:                         ; объявление метки _start - точки входа в программу
    
    ; Вывод приглашения для ввода строки N
    mov rax, 1                  ; 1 - номер системного вызова функции write, rax=1 — запись в файл.
    mov rdi, 1                  ; 1 - дескриптор файла стандартного вызова stdout. rdi=1 — стандартный вывод (консоль).
    mov rsi, message1           ; адрес строки для вывод, rsi — указатель на строку.
    mov rdx, message1_len       ; количество байтов, rdx — длина строки.
    syscall                     ; выполняем системный вызов write, syscall — выполняет вывод.


    ; Ввод строки N
    mov rax, 0                  ;0 - номер системного вызова функции read, rax=0 — чтение из файла.
    mov rdi, 0                  ;0 - дескриптор файла стандартного вызова stdin. rdi=0 — стандартный ввод (клавиатура).
    mov rsi, N                  ;Буфер для ввода (адрес N). rsi=N — куда сохранять ввод.
    mov rdx, 256                ;rdx=256 — максимальное число байт для чтения.
    syscall                     ; Чтение ввода


    ; Удаление символа новой строки (\n)
    mov rsi, N                  ; Адрес строки N
    mov rcx, rax                ; Количество прочитанных байт (из syscall read)
    dec rcx                     ; Уменьшаем на 1 (последний символ — `\n`). dec rcx — пропускаем \n
    mov byte [rsi + rcx], 0     ; Заменяем `\n` на нулевой байт (конец строки)


    ; Вывод приглашения для ввода позиции P
    mov rax, 1                  ; 1 - номер системного вызова функции write, rax=1 — запись в файл.
    mov rdi, 1                  ; 1 - дескриптор файла стандартного вызова stdout. rdi=1 — стандартный вывод (консоль).
    mov rsi, message2           ; адрес строки для вывод, rsi — указатель на строку.
    mov rdx, message2_len       ; количество байтов, rdx — длина строки.
    syscall                     ; выполняем системный вызов write, syscall — выполняет вывод.

    ; Ввод позиции P
    mov rax, 0                  ;0 - номер системного вызова функции read, rax=0 — чтение из файла.
    mov rdi, 0                  ;0 - дескриптор файла стандартного вызова stdin. rdi=0 — стандартный ввод (клавиатура).
    mov rsi, P                  ;Буфер для ввода (адрес P). rsi=P — куда сохранять ввод.
    mov rdx, 256                ;rdx=256 — максимальное число байт для чтения.
    syscall                     ; Чтение ввода

    ; Удаление символа новой строки (\n)
    mov rsi, P                  ; Адрес строки N
    mov rcx, rax                ; Количество прочитанных байт (из syscall read)
    dec rcx                     ; Уменьшаем на 1 (последний символ — `\n`). dec rcx — пропускаем \n
    mov byte [rsi + rcx], 0     ; Заменяем `\n` на нулевой байт (конец строки)

    
    ; Конвертация P в число
    mov rsi, P                  ; Адрес строки P
    call count                   ; Преобразуем строку в число
    mov [P], eax                ; Сохраняем число в переменную P

    ; Вычисление длины строки N
    mov rsi, N                  ; Адрес строки N
    call strlen                 ;call strlen — вызывает функцию strlen, которая возвращает длину строки в rax.
    mov rbx, rax                ; сохраняем длину строки в rbx


    ; Проверка корректности позиции P
    cmp dword [P], 0            ; P ≤ 0?
    jle error                   ; Если да — ошибка
    cmp dword [P], ebx          ; P > длины строки?
    jg error                    ; Если да — ошибка


    ; Вычисление позиции с конца (P_new = длина - P)
    mov eax, ebx                ; Длина строки
    sub eax, [P]                ; Вычитаем P (новая позиция = длина - P)
    mov [P], eax                ; Сохраняем новую позицию


    ; Вывод символа на вычисленной позиции
    mov rsi, N                  ; Адрес строки N
    mov eax, [P]                ; Загружаем вычисленную позицию
    movzx rax, byte [rsi + rax] ; загружаем символ по индексу
    push rax                    ; Кладём символ в стек
    mov rsi, rsp                ; Указываем на него (для syscall)

    
    mov rax, 1                  ; 1 - номер системного вызова функции write, rax=1 — запись в файл.
    mov rdi, 1                  ; 1 - дескриптор файла стандартного вызова stdout. rdi=1 — стандартный вывод (консоль).
    mov rdx, 1                  ; количество байтов, rdx — длина строки(выводим 1 символ)
    syscall                     


    ; Завершение программы
    mov rax, 60                 ; 60 - номер системного вызова exit
    xor rdi, rdi                ; Код возврата 0 (успех). исключающего ИЛИ если соответствующие разряды обоих операндов не равны, то возвращается 1, если равны — 0
    syscall                     ; выполняем системный вызов exit


; Функция для вывода сообщения об ошибке ошибке
error:
    ; Вывод сообщения об ошибке

    mov rax, 1                  ; 1 - номер системного вызова функции write, rax=1 — запись в файл.
    mov rdi, 1                  ; 1 - дескриптор файла стандартного вызова stdout. rdi=1 — стандартный вывод (консоль).
    mov rsi, error_message      ; адрес строки для вывод, rsi — указатель на строку.
    mov rdx, error_len          ; количество байтов, rdx — длина строки.
    syscall                     ; выполняем системный вызов write, syscall — выполняет вывод.


    ; Завершение с кодом ошибки
    mov rax, 60                 ; 60 - номер системного вызова exit
    mov rdi, 1                  ; Код возврата 1 (ошибка)
    syscall                     ; выполняем системный вызов exit


; Функция для преобразования строки в число
count:                          ; Начало функции count (принимает адрес строки в rsi)
    xor eax, eax                ; Обнуляем eax (результат)
.loop:
    movzx ecx, byte [rsi]      ; Загружаем текущий символ
    test ecx, ecx               ; Проверяем, является ли символ нулевым
    jz .end                     ; Если да, выходим
    sub ecx, '0'                ; Преобразуем ASCII-цифру в число
    imul eax, eax, 10           ; Умножаем результат на 10
    add eax, ecx                ; Добавляем текущую цифру
    inc rsi                     ; Переходим к следующему символу
    jmp .loop                   ; Возвращаемся к началу цикла
.end:                           ; Метка выхода из цикла
    ret                         ; Возврат из функции (возвращает длину строки в rax) 


; Функция для нахождения длины строки
strlen:                         ; Начало функции strlen (принимает адрес строки в rsi)
    xor rax, rax                ;обнуляет rax (счётчик длины). xor (исключающее ИЛИ) — это быстрый способ обнулить регистр.
.loop:                          ; Метка начала цикла

    ;rsi — содержит адрес начала строки (передан в функцию). rax — текущий индекс (смещение от начала строки).
    cmp byte [rsi + rax], 0     ; проверяет конец строки (0). Дошли до нулевого байта?
    je .end                     ; Если да — выходим. переход, если предыдущее сравнение (cmp) верно.
    inc rax                     ; Увеличиваем счётчик (длину) на 1
    jmp .loop                   ; Возвращаемся к началу 
.end:                           ; Метка выхода из цикла
    ret                         ; Возврат из функции (возвращает длину строки в rax) 